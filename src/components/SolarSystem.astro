---
import type { CollectionEntry } from 'astro:content';

type ProjectLite = {
	id: string;
	title: string;
	description: string;
	avatar?: string;
	url: string;
};

type Props = {
	projects: CollectionEntry<'projects'>[];
	name?: string;
	baseHref?: string;
};

const { projects, name = 'Григорий', baseHref = '' } = Astro.props;

const locale = baseHref.startsWith('/en') ? 'en' : baseHref.startsWith('/udm') ? 'udm' : 'ru';
const controlsAlt =
	locale === 'en'
		? 'Controls: drag to rotate, wheel/pinch to zoom, right click / two-finger drag to pan. Click a planet to open the project. Fullscreen available.'
		: locale === 'udm'
			? 'Управление: мышен кыдӟыса — берган, колёсико/пинч — зум, ПКМ / кык пальцэн — панорама. Планета вылын клик — проектез усьтоно. Fullscreen уг быгатыш.'
			: 'Управление: перетаскивание — вращение, колёсико/пинч — зум, ПКМ / двумя пальцами — панорама. Клик по планете — открыть проект. Есть fullscreen.';

const fullscreenLabel = locale === 'en' ? 'Fullscreen' : locale === 'udm' ? 'Fullscreen' : 'На весь экран';

const projectData: ProjectLite[] = projects.map((p) => ({
	id: p.id,
	title: p.data.title,
	description: p.data.description,
	avatar: p.data.avatar,
	url: `${baseHref}/projects/${p.id}/`,
}));
---

<section class="ss" aria-label="Портфолио в виде солнечной системы">
	<div class="ss__stage" id="ss-stage">
		<canvas class="ss__canvas" id="ss-canvas" aria-label="3D солнечная система" role="img"></canvas>
		<div class="ss__hint" aria-hidden="true" title={controlsAlt}>
			<span class="sr-only">{controlsAlt}</span>
			<div class="ss__icons">
				<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
					<path fill="currentColor" d="M12 4a8 8 0 1 0 8 8h-2a6 6 0 1 1-1.76-4.24L14 10h6V4l-2.34 2.34A7.97 7.97 0 0 0 12 4z"/>
				</svg>
				<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
					<path fill="currentColor" d="M10.5 3a7.5 7.5 0 1 0 4.6 13.4l3.15 3.15a1 1 0 0 0 1.41-1.41l-3.15-3.15A7.5 7.5 0 0 0 10.5 3zm0 2a5.5 5.5 0 1 1 0 11a5.5 5.5 0 0 1 0-11zm0 2a1 1 0 0 1 1 1v1.5H13a1 1 0 1 1 0 2h-1.5V13a1 1 0 1 1-2 0v-1.5H8a1 1 0 1 1 0-2h1.5V8a1 1 0 0 1 1-1z"/>
				</svg>
				<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
					<path fill="currentColor" d="M12 3l3 3h-2v5h-2V6H9l3-3zm0 18l-3-3h2v-5h2v5h2l-3 3zM3 12l3-3v2h5v2H6v2l-3-3zm18 0l-3 3v-2h-5v-2h5V9l3 3z"/>
				</svg>
			</div>
		</div>
		<button class="ss__fs" id="ss-fs" type="button" title={fullscreenLabel} aria-label={fullscreenLabel}>
			<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
				<path fill="currentColor" d="M7 3H3v4a1 1 0 1 0 2 0V5h2a1 1 0 1 0 0-2zm14 0h-4a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0V3zM3 21h4a1 1 0 1 0 0-2H5v-2a1 1 0 1 0-2 0v4zm18-4a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h4v-4z"/>
			</svg>
		</button>
		<aside class="ss__panel" id="ss-panel" hidden>
			<button class="ss__panelClose" id="ss-panel-close" type="button" aria-label="Close" title="Close">
				<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
					<path fill="currentColor" d="M18.3 5.71a1 1 0 0 0-1.41 0L12 10.59L7.11 5.7A1 1 0 1 0 5.7 7.11L10.59 12l-4.9 4.89a1 1 0 1 0 1.41 1.42L12 13.41l4.89 4.9a1 1 0 0 0 1.42-1.41L13.41 12l4.9-4.89a1 1 0 0 0-.01-1.4z"/>
				</svg>
			</button>
			<a class="ss__panelTitle" id="ss-panel-title" href="#"></a>
			<div class="ss__panelDesc" id="ss-panel-desc"></div>
		</aside>
		<div class="ss__tooltip" id="ss-tooltip" hidden>
			<div class="ss__tooltipTitle" id="ss-tooltip-title"></div>
			<div class="ss__tooltipDesc" id="ss-tooltip-desc"></div>
		</div>
		<div class="ss__fallback" id="ss-fallback" hidden>
			<h1>Проекты</h1>
			<ul>
				{projectData.map((p) => (
					<li><a href={p.url}>{p.title}</a> — {p.description}</li>
				))}
			</ul>
		</div>
		<noscript>
			<div class="ss__fallback">
				<h1>Проекты</h1>
				<ul>
					{projectData.map((p) => (
						<li><a href={p.url}>{p.title}</a> — {p.description}</li>
					))}
				</ul>
			</div>
		</noscript>
		<script type="application/json" id="ss-data" set:html={JSON.stringify(projectData)}></script>
	</div>
</section>

<style>
	.ss {
		width: 100%;
	}
	.ss__stage {
		position: relative;
		width: 100%;
		height: min(860px, calc(100vh - 120px));
		min-height: 520px;
		border-radius: 16px;
		overflow: hidden;
		background: radial-gradient(circle at 50% 30%, rgba(35, 55, 255, 0.12), transparent 55%),
			linear-gradient(180deg, rgba(15, 18, 25, 0.92), rgba(15, 18, 25, 0.98));
		box-shadow: var(--box-shadow);
	}
	.ss__canvas {
		width: 100%;
		height: 100%;
		display: block;
		outline: none;
	}
	.ss__hint {
		position: absolute;
		left: 1rem;
		top: 1rem;
		pointer-events: none;
		padding: 0.35rem 0.45rem;
		border-radius: 10px;
		background: transparent;
		color: rgba(255, 255, 255, 0.45);
		backdrop-filter: none;
		box-shadow: none;
		max-width: min(520px, calc(100% - 2rem));
		font-size: 0.9rem;
		line-height: 1.25;
	}
	.ss__icons {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}
	.ss__icons svg {
		display: block;
		opacity: 0.9;
	}
	.ss__fs {
		position: absolute;
		right: 0.75rem;
		top: 0.75rem;
		padding: 0.55rem;
		border-radius: 10px;
		border: 1px solid rgba(255, 255, 255, 0.14);
		background: rgba(0, 0, 0, 0.08);
		color: rgba(255, 255, 255, 0.62);
		cursor: pointer;
	}
	.ss__fs:hover {
		background: rgba(0, 0, 0, 0.16);
	}
	.ss__panel {
		position: absolute;
		right: 0.75rem;
		bottom: 0.75rem;
		width: min(420px, calc(100% - 1.5rem));
		box-sizing: border-box;
		padding: 0.95rem 0.95rem 0.9rem;
		border-radius: 14px;
		border: 1px solid rgba(255, 255, 255, 0.12);
		background: rgba(12, 15, 22, 0.72);
		color: rgba(255, 255, 255, 0.9);
		backdrop-filter: blur(10px);
		box-shadow: 0 18px 46px rgba(0, 0, 0, 0.45);
	}
	.ss__panelTitle {
		display: inline-block;
		font-weight: 700;
		font-size: 1.05rem;
		line-height: 1.25;
		padding-right: 2.25rem;
		color: inherit;
		text-decoration: none;
	}
	.ss__panelTitle:hover {
		text-decoration: underline;
	}
	.ss__panelDesc {
		margin-top: 0.45rem;
		font-size: 0.95rem;
		line-height: 1.4;
		color: rgba(255, 255, 255, 0.78);
	}
	.ss__panelClose {
		position: absolute;
		right: 0.55rem;
		top: 0.55rem;
		padding: 0.45rem;
		border-radius: 10px;
		border: 1px solid rgba(255, 255, 255, 0.12);
		background: rgba(0, 0, 0, 0.12);
		color: rgba(255, 255, 255, 0.8);
		cursor: pointer;
	}
	.ss__panelClose:hover {
		background: rgba(0, 0, 0, 0.18);
	}
	.ss__tooltip {
		position: absolute;
		pointer-events: none;
		transform: translate(-50%, -120%);
		padding: 0.7rem 0.85rem;
		border-radius: 12px;
		background: rgba(255, 255, 255, 0.92);
		color: rgb(var(--gray-dark));
		backdrop-filter: blur(10px);
		box-shadow: 0 12px 30px rgba(0, 0, 0, 0.22);
		max-width: min(360px, calc(100% - 2rem));
	}
	.ss__tooltipTitle {
		font-weight: 700;
		line-height: 1.2;
		margin-bottom: 0.25rem;
	}
	.ss__tooltipDesc {
		font-size: 0.95rem;
		line-height: 1.35;
		color: rgba(34, 41, 57, 0.9);
	}
	.ss__fallback {
		padding: 2rem;
		background: #fff;
		border-radius: 16px;
	}
	.ss__fallback ul {
		margin: 0;
		padding-left: 1.2rem;
	}

	@media (max-width: 720px) {
		.ss__stage {
			height: calc(100vh - 86px);
			min-height: 480px;
			border-radius: 12px;
		}
		.ss__hint {
			left: 0.75rem;
			top: 0.75rem;
			padding: 0.3rem 0.4rem;
		}
		.ss__fs {
			right: 0.6rem;
			top: 0.6rem;
			padding: 0.5rem;
		}
		.ss__panel {
			right: 0.6rem;
			left: 0.6rem;
			bottom: 0.6rem;
			width: auto;
			padding: 0.85rem 0.85rem 0.8rem;
		}
	}
</style>

<script>
	// @ts-nocheck
	import * as THREE from 'three';
	import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

	const stage = document.getElementById('ss-stage');
	const canvas = document.getElementById('ss-canvas');
	const tooltip = document.getElementById('ss-tooltip');
	const tooltipTitle = document.getElementById('ss-tooltip-title');
	const tooltipDesc = document.getElementById('ss-tooltip-desc');
	const panel = document.getElementById('ss-panel');
	const panelTitle = document.getElementById('ss-panel-title');
	const panelDesc = document.getElementById('ss-panel-desc');
	const panelClose = document.getElementById('ss-panel-close');
	const dataScript = document.getElementById('ss-data');
	const fallback = document.getElementById('ss-fallback');
	const fsBtn = document.getElementById('ss-fs');

	if (!stage || !canvas || !tooltip || !tooltipTitle || !tooltipDesc || !panel || !panelTitle || !panelDesc || !panelClose || !dataScript) {
		// Not on this page / partially rendered.
	} else {
		const projects = JSON.parse(dataScript.textContent || '[]');

		let renderer = null;
		let camera = null;
		let scene = null;
		let animationHandle = 0;
		let controlsRef = null;
		let onFsClick = null;
		let onPanelClickStop = null;
		let onPanelCloseClick = null;

		let selected = null;
		const defaultCameraPos = new THREE.Vector3();
		const defaultTarget = new THREE.Vector3(0, 0.8, 0);
		const tempVec3 = new THREE.Vector3();
		const tempVec3b = new THREE.Vector3();

		const cameraAnim = {
			active: false,
			start: 0,
			duration: 520,
			fromPos: new THREE.Vector3(),
			toPos: new THREE.Vector3(),
			fromTarget: new THREE.Vector3(),
			toTarget: new THREE.Vector3(),
			onDone: null,
		};

		const raycaster = new THREE.Raycaster();
		const pointerNdc = new THREE.Vector2();

		const planets = [];
		let hovered = null;
		let isInteracting = false;
		let didDrag = false;
		let isPointerDown = false;
		let pointerDownX = 0;
		let pointerDownY = 0;
		const textureLoader = new THREE.TextureLoader();

		function getStageSize() {
			const rect = stage.getBoundingClientRect();
			return { width: Math.max(1, rect.width), height: Math.max(1, rect.height) };
		}

		function init() {
			const { width, height } = getStageSize();

			renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
			renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
			renderer.setSize(width, height, false);
			renderer.outputColorSpace = THREE.SRGBColorSpace;

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 2000);

			const baseRadius = 10;
			const radiusStep = 5.2;
			const maxOrbit = baseRadius + Math.max(0, projects.length - 1) * radiusStep;
			const systemRadius = maxOrbit + 6;
			const tanHalfFov = Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5));
			const fitDistV = systemRadius / tanHalfFov;
			const fitDistH = systemRadius / (tanHalfFov * camera.aspect);
			const fitDist = Math.max(fitDistV, fitDistH);

			const cameraDistance = fitDist * 1.04;
			const cameraHeight = systemRadius * 0.75 + 8;
			const cameraSide = systemRadius * 0.14;
			camera.position.set(cameraSide, cameraHeight, cameraDistance);
			camera.lookAt(0, 0.8, 0);
			defaultCameraPos.copy(camera.position);

			controlsRef = new OrbitControls(camera, renderer.domElement);
			const controls = controlsRef;
			controls.enableDamping = true;
			controls.dampingFactor = 0.08;
			controls.enablePan = true;
			controls.panSpeed = 0.9;
			controls.rotateSpeed = 0.6;
			controls.zoomSpeed = 1.15;
			controls.minDistance = 3.5;
			controls.maxDistance = Math.max(140, fitDist * 2.8);
			controls.target.set(0, 0.8, 0);
			controls.update();

			// Lights
			scene.add(new THREE.AmbientLight(0xffffff, 0.36));
			scene.add(new THREE.HemisphereLight(0xffffff, 0x0b1020, 0.22));
			const sunLight = new THREE.PointLight(0xfff2cc, 2.2, 250, 2);
			sunLight.position.set(0, 0, 0);
			scene.add(sunLight);

			// Stars
			const starsGeom = new THREE.BufferGeometry();
			const starCount = 1200;
			const starPositions = new Float32Array(starCount * 3);
			for (let i = 0; i < starCount; i++) {
				const r = 700;
				starPositions[i * 3 + 0] = (Math.random() - 0.5) * r;
				starPositions[i * 3 + 1] = (Math.random() - 0.5) * r;
				starPositions[i * 3 + 2] = (Math.random() - 0.5) * r;
			}
			starsGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
			const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.75 });
			const stars = new THREE.Points(starsGeom, starsMat);
			scene.add(stars);

			// Sun
			const sunGeom = new THREE.SphereGeometry(4.2, 48, 48);
			const sunMat = new THREE.MeshStandardMaterial({
				color: 0xffcc55,
				emissive: 0xffaa33,
				emissiveIntensity: 1.4,
				metalness: 0.1,
				roughness: 0.35,
			});
			const sun = new THREE.Mesh(sunGeom, sunMat);
			sun.name = 'sun';
			scene.add(sun);

			const glowGeom = new THREE.SphereGeometry(5.6, 32, 32);
			const glowMat = new THREE.MeshBasicMaterial({ color: 0xffc04d, transparent: true, opacity: 0.18, blending: THREE.AdditiveBlending, depthWrite: false });
			const glow = new THREE.Mesh(glowGeom, glowMat);
			glow.renderOrder = 1;
			scene.add(glow);

			// Planets
			// Planets
			const palette = [0x7dd3fc, 0xa7f3d0, 0xfde68a, 0xfca5a5, 0xc4b5fd, 0xfdba74, 0x93c5fd, 0xf9a8d4];

			projects.forEach((p, index) => {
				const orbitRadius = baseRadius + index * radiusStep;
				const planetRadius = 1.18 + (index % 3) * 0.22;

				const pivot = new THREE.Object3D();
				scene.add(pivot);

				const geom = new THREE.SphereGeometry(planetRadius, 36, 36);
				const mat = new THREE.MeshStandardMaterial({
					color: palette[index % palette.length],
					emissive: 0x000000,
					metalness: 0.1,
					roughness: 0.7,
				});
				if (p.avatar) {
					const tex = textureLoader.load(p.avatar);
					tex.colorSpace = THREE.SRGBColorSpace;
					tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
					mat.map = tex;
					mat.color.set(0xffffff);
					mat.roughness = 0.95;
					mat.metalness = 0.0;
					mat.needsUpdate = true;
				}
				const mesh = new THREE.Mesh(geom, mat);
				mesh.position.set(orbitRadius, 0, 0);
				mesh.userData = { url: p.url, title: p.title, description: p.description };
				pivot.add(mesh);

				// Orbit ring
				const ringGeom = new THREE.RingGeometry(orbitRadius - 0.02, orbitRadius + 0.02, 128);
				const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.08, side: THREE.DoubleSide });
				const ring = new THREE.Mesh(ringGeom, ringMat);
				ring.rotation.x = Math.PI / 2;
				scene.add(ring);

				planets.push({
					mesh,
					pivot,
					orbitRadius,
					orbitSpeed: 0.12 + index * 0.02,
					spinSpeed: 0.6 + (index % 4) * 0.2,
					data: p,
				});
			});

			// Tilt the whole system a bit for more 3D depth
			scene.rotation.x = -0.18;
			scene.rotation.z = -0.06;

			bindEvents(controls);
			animate(0, controls);
		}

		function showPanel(data) {
			panelTitle.textContent = String(data?.title || '');
			panelTitle.href = String(data?.url || '#');
			panelDesc.textContent = String(data?.description || '');
			panel.hidden = false;
		}

		function hidePanel() {
			panel.hidden = true;
		}

		function easeInOut(t) {
			return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
		}

		function startCameraAnim(toPos, toTarget, onDone) {
			if (!camera || !controlsRef) return;
			cameraAnim.active = true;
			cameraAnim.start = performance.now();
			cameraAnim.fromPos.copy(camera.position);
			cameraAnim.toPos.copy(toPos);
			cameraAnim.fromTarget.copy(controlsRef.target);
			cameraAnim.toTarget.copy(toTarget);
			cameraAnim.onDone = typeof onDone === 'function' ? onDone : null;
		}

		function focusOnPlanet(planet) {
			if (!camera || !controlsRef) return;
			const planetPos = planet.mesh.getWorldPosition(tempVec3).clone();
			const radius = planet.mesh.geometry?.boundingSphere?.radius ? planet.mesh.geometry.boundingSphere.radius : 1.2;
			const desiredDist = Math.max(8, radius * 7);

			const dir = new THREE.Vector3().subVectors(camera.position, controlsRef.target).normalize();
			const up = new THREE.Vector3(0, 1, 0);
			const right = new THREE.Vector3().crossVectors(up, dir).normalize();

			const offset = dir
				.multiplyScalar(desiredDist)
				.addScaledVector(up, desiredDist * 0.45)
				.addScaledVector(right, desiredDist * 0.18);

			const toPos = planetPos.clone().add(offset);
			startCameraAnim(toPos, planetPos);
		}

		function resetCamera() {
			startCameraAnim(defaultCameraPos, defaultTarget, () => {
				selected = null;
				hidePanel();
			});
		}

		function bindEvents(controls) {
			stage.style.cursor = 'grab';

			stage.addEventListener('pointerdown', onPointerDown);
			stage.addEventListener('pointerup', onPointerUp);
			stage.addEventListener('pointercancel', onPointerCancel);
			stage.addEventListener('pointermove', onPointerMove);
			stage.addEventListener('pointerleave', onPointerLeave);
			stage.addEventListener('click', onClick);
			window.addEventListener('resize', onResize);

			controls.addEventListener('start', () => {
				isInteracting = true;
				tooltip.hidden = true;
			});
			controls.addEventListener('end', () => {
				isInteracting = false;
			});

			document.addEventListener('astro:before-swap', dispose, { once: true });

			onPanelCloseClick = (ev) => {
				ev.stopPropagation();
				ev.preventDefault();
				hidePanel();
				startCameraAnim(defaultCameraPos, defaultTarget, () => {
					selected = null;
				});
			};
			panelClose.addEventListener('click', onPanelCloseClick);

			onPanelClickStop = (ev) => {
				ev.stopPropagation();
			};
			panel.addEventListener('click', onPanelClickStop);

			if (fsBtn && stage.requestFullscreen && document.fullscreenEnabled) {
				onFsClick = async (ev) => {
					ev?.stopPropagation?.();
					try {
						if (document.fullscreenElement) {
							await document.exitFullscreen();
						} else {
							await stage.requestFullscreen();
						}
					} catch {
						// ignore
					}
				};
				fsBtn.addEventListener('click', onFsClick);
				document.addEventListener('fullscreenchange', onResize);
			} else if (fsBtn) {
				fsBtn.setAttribute('hidden', '');
			}
		}

		function onResize() {
			if (!renderer || !camera) return;
			const { width, height } = getStageSize();
			renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
			renderer.setSize(width, height, false);
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
		}

		function setPointerFromEvent(ev) {
			const rect = stage.getBoundingClientRect();
			const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
			const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
			pointerNdc.set(x, y);
		}

		function onPointerDown(ev) {
			isPointerDown = true;
			didDrag = false;
			pointerDownX = ev.clientX;
			pointerDownY = ev.clientY;
		}

		function onPointerUp() {
			isPointerDown = false;
		}

		function onPointerCancel() {
			isPointerDown = false;
		}

		function onPointerMove(ev) {
			if (!camera || !scene) return;
			if (isPointerDown) {
				const dx = ev.clientX - pointerDownX;
				const dy = ev.clientY - pointerDownY;
				if (dx * dx + dy * dy > 36) didDrag = true;
			}
			if (selected) {
				hovered = null;
				tooltip.hidden = true;
				stage.style.cursor = 'grab';
				return;
			}
			if (isInteracting) {
				hovered = null;
				tooltip.hidden = true;
				return;
			}
			setPointerFromEvent(ev);
			raycaster.setFromCamera(pointerNdc, camera);
			const hits = raycaster.intersectObjects(planets.map((p) => p.mesh), false);
			const hit = hits[0] ? hits[0].object : null;

			if (!hit) {
				hovered = null;
				tooltip.hidden = true;
				stage.style.cursor = 'grab';
				return;
			}

			const planet = planets.find((p) => p.mesh === hit) || null;
			hovered = planet;
			stage.style.cursor = 'pointer';

			const title = String(hit.userData?.title || '');
			const description = String(hit.userData?.description || '');
			tooltipTitle.textContent = title;
			tooltipDesc.textContent = description;
			tooltip.hidden = false;
		}

		function onPointerLeave() {
			isPointerDown = false;
			hovered = null;
			tooltip.hidden = true;
			stage.style.cursor = 'grab';
		}

		function onClick(ev) {
			if (didDrag) return;
			if (cameraAnim.active) return;
			if (!camera) return;

			setPointerFromEvent(ev);
			raycaster.setFromCamera(pointerNdc, camera);
			const hits = raycaster.intersectObjects(planets.map((p) => p.mesh), false);
			const hit = hits[0] ? hits[0].object : null;
			if (!hit) return;
			const planet = planets.find((p) => p.mesh === hit) || null;
			if (!planet) return;

			selected = planet;
			tooltip.hidden = true;
			showPanel({ title: hit.userData?.title, description: hit.userData?.description, url: planet.data?.url });
			focusOnPlanet(planet);
		}

		function updateTooltipPosition() {
			if (!hovered || !camera || !tooltip) return;
			const pos = hovered.mesh.getWorldPosition(new THREE.Vector3());
			pos.project(camera);

			const rect = stage.getBoundingClientRect();
			const x = (pos.x * 0.5 + 0.5) * rect.width;
			const y = (-pos.y * 0.5 + 0.5) * rect.height;

			tooltip.style.left = `${x}px`;
			tooltip.style.top = `${y}px`;
		}

		function animate(t, controls) {
			animationHandle = requestAnimationFrame((tt) => animate(tt, controls));
			if (!renderer || !scene || !camera) return;

			const time = t * 0.001;
			if (cameraAnim.active && controlsRef) {
				const now = performance.now();
				const u = Math.min(1, (now - cameraAnim.start) / cameraAnim.duration);
				const e = easeInOut(u);
				camera.position.lerpVectors(cameraAnim.fromPos, cameraAnim.toPos, e);
				controlsRef.target.lerpVectors(cameraAnim.fromTarget, cameraAnim.toTarget, e);
				controlsRef.update();
				if (u >= 1) {
					cameraAnim.active = false;
					const done = cameraAnim.onDone;
					cameraAnim.onDone = null;
					if (typeof done === 'function') done();
				}
			} else {
				controls.update();
			}

			for (const p of planets) {
				p.pivot.rotation.y = time * p.orbitSpeed;
				p.mesh.rotation.y = time * p.spinSpeed;
			}

			if (selected && controlsRef && !cameraAnim.active) {
				const newTarget = selected.mesh.getWorldPosition(tempVec3);
				const delta = tempVec3b.subVectors(newTarget, controlsRef.target);
				controlsRef.target.add(delta);
				camera.position.add(delta);
				controlsRef.update();
			}

			updateTooltipPosition();
			renderer.render(scene, camera);
		}

		function dispose() {
			cancelAnimationFrame(animationHandle);

			stage?.removeEventListener('pointerdown', onPointerDown);
			stage?.removeEventListener('pointerup', onPointerUp);
			stage?.removeEventListener('pointercancel', onPointerCancel);
			stage?.removeEventListener('pointermove', onPointerMove);
			stage?.removeEventListener('pointerleave', onPointerLeave);
			stage?.removeEventListener('click', onClick);
			window.removeEventListener('resize', onResize);
			document.removeEventListener('fullscreenchange', onResize);
			if (fsBtn && onFsClick) fsBtn.removeEventListener('click', onFsClick);
			onFsClick = null;
			if (panel && onPanelClickStop) panel.removeEventListener('click', onPanelClickStop);
			onPanelClickStop = null;
			if (panelClose && onPanelCloseClick) panelClose.removeEventListener('click', onPanelCloseClick);
			onPanelCloseClick = null;
			controlsRef?.dispose?.();
			controlsRef = null;

			planets.length = 0;
			hovered = null;
			selected = null;
			hidePanel();

			function disposeMaterial(m) {
				if (!m) return;
				if (m.map && m.map.dispose) m.map.dispose();
				if (m.emissiveMap && m.emissiveMap.dispose) m.emissiveMap.dispose();
				if (m.normalMap && m.normalMap.dispose) m.normalMap.dispose();
				if (m.roughnessMap && m.roughnessMap.dispose) m.roughnessMap.dispose();
				if (m.metalnessMap && m.metalnessMap.dispose) m.metalnessMap.dispose();
				if (m.alphaMap && m.alphaMap.dispose) m.alphaMap.dispose();
				if (m.aoMap && m.aoMap.dispose) m.aoMap.dispose();
				if (m.dispose) m.dispose();
			}

			if (scene) {
				scene.traverse((obj) => {
					if (obj && obj.isMesh) {
						const mesh = obj;
						if (mesh.geometry && mesh.geometry.dispose) mesh.geometry.dispose();
						const mat = mesh.material;
						if (Array.isArray(mat)) {
							mat.forEach(disposeMaterial);
						} else if (mat && mat.dispose) {
							disposeMaterial(mat);
						}
					}
				});
			}

			renderer?.dispose();
			renderer = null;
			camera = null;
			scene = null;
		}

		try {
			init();
		} catch {
			// If WebGL fails, show fallback list.
			if (fallback) fallback.hidden = false;
			canvas.hidden = true;
			tooltip.hidden = true;
			const hint = stage.querySelector('.ss__hint');
			if (hint) hint.setAttribute('hidden', '');
			if (fsBtn) fsBtn.setAttribute('hidden', '');
		}
	}
</script>
